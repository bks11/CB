unit Unit3;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, DB, DBTables, ShellApi;

Const
 NAME_LEN=12;
 ALIAS_LEN=120;
type

  Check_Status = Record
   Name : Array [0..NAME_LEN] Of Char;
   Alias : Array [0..ALIAS_LEN] Of Char;
   Position : Byte;
   Status : Byte;
   Date : DWORD;
  End;
  pCheck_Status=^ACheck_Status;
  ACheck_Status = Array [0..0] Of Check_Status;
  TVerba = Object
   PathFileIn:String;
   PathFileOut:String;
   Key:Array [1..8] Of String;
   OpenKey:Array [1..4] Of String;
   PathKey:Array [1..4] Of String;
   PathOpenKey:Array [1..4] Of String;
   Folder:String;
   FolderOut:String;
   public
    { Private declarations }
   Procedure VerbaInit;{Разкриптовать 2 ключем}
   Procedure RepathFile;{проставить // в пути к фаилу}
   Function Uncript(KeyId:Integer):Word;{Разкриптовать}
   Function UncriptFolder(KeyId:Integer):Word;{Разкриптовать}
   Function Cript(KeyId:Integer):Word;{Закриптовать}
   Function CriptFolder(KeyId:Integer):Word;{Закриптовать}
   Function Sign(KeyId:Integer):Word;{Подписать}
   Function SignFolder(KeyId:Integer):Word;{Подписать}
   Function UnCaFolder(KeyId:Integer):Word;
  End;
  TForm3 = class(TForm)
    Query1: TQuery;
    Query2: TQuery;
    Query3: TQuery;
    Query4: TQuery;
    Query5: TQuery;
    Query6: TQuery;
    Query7: TQuery;
    Query8: TQuery;
    Query9: TQuery;
    Query10: TQuery;
    Query11: TQuery;
    Query12: TQuery;
    Query13: TQuery;
    Query14: TQuery;
  private
    { Private declarations }
  public
    { Public declarations }
  end;

var
  Form3: TForm3;

implementation

uses
 Unit1;

{$R *.dfm}

{******Функции инициализации и завершения работы с библиотекой*******}
{PathToSecret - путь к закрытым ключам шифрования}
{PathToBase - Путь к открытым ключам}
function CryptoInit(PathToSecret,PathToBase:String ):Word;
 stdcall; external 'WBOTHO.DLL' name 'CryptoInit';
function SignInit(PathToSecret,PathToBase:String ):Word;
 stdcall; external 'WBOTHO.DLL' name 'SignInit';
function SignDone:Word;
 stdcall; external 'WBOTHO.DLL' name 'SignDone';
function CryptoDone:Word;
 stdcall; external 'WBOTHO.DLL' name 'CryptoDone';
{***************Шифрование фаилов****************}
{Получить идентификатор ключа абонента, зашифровавшего файл}
{path - путь к зашифрованному файлу}
{sender_id - указатель для строки с 10-байтовым идентификатором}
function GetFileSenderID(path,sender_id:LPSTR):Word;
  stdcall; external 'WBOTHO.DLL' name 'GetFileSenderID';
{Получить список абонентов, которым адресован файл}
{file_name - Зашифрованный файл}
{abonents - число получателей}
{user_list - список абонентов}
{ser - номер подсети(серии), откуда направлен файл}
function GetCryptKeysF(file_name:LPSTR; abonents:PWORD;user_list:PWORD;ser:LPSTR):Word;
 stdcall; external 'WBOTHO.DLL' name 'GetCryptKeysF';
{file_in - открытый файл}
{file_out - зашифрованный файл}
{From - идентификатор ключа отправителя ("XXXXSSSSSS")}
{open_keys_array - массив указателей на открытые ключи получателей}
{open_keys_quantity - количество получателей}
function EnCryptFileEx(file_in,file_out,From:LPSTR;Open_Key_Array:Pointer;Open_Keys_Quantity:Word;Flags:DWORD):WORD;
 stdcall; external 'WBOTHO.DLL' name 'EnCryptFileEx';
{file_in - открытый файл}
{file_out - зашифрованный файл}
{node_From - свой идентификатор}
{node_To - список криптографических номеров получателей,}
{ser - номер подсети(серии), куда направляется файл}
function EnCryptFile(file_in,file_out:LPSTR;node_From:WORD;node_To:PWORD;ser:LPSTR):WORD ;
  stdcall; external 'WBOTHO.DLL' name 'EnCryptFile';
{file_in - Зашифрованный файл}
{file_out - расшифрованный файл}
{abonent - идентификатор ключа  получателя("XXXXSSSSSS")}
{pub_key - указатель на открытый ключ отправителя}
function DeCryptFileEx(file_in,file_out,abonent:LPSTR;pub_key:Pointer):WORD;
 stdcall; external 'WBOTHO.DLL' name 'DeCryptFileEx';
{*********Формирование случайного числа**************}
{buff - указатель на буфер для случайной последовательности}
{rnd_size - длина случайной последовательности}
function Rndm(buff:Pointer;rnd_size:DWORD):WORD;
 stdcall; external 'WBOTHO.DLL' name 'Rndm';
function InitRndm (key_dev:String; key_ID:DWORD):WORD;
  stdcall; external 'WBOTHO.DLL' name 'InitRndm';
{*************Загрузка и удалению ключа подписи***********************}
{path - полный путь к файлу с секретным ключом подписи}
function SignLogIn(path:LPSTR):WORD;
 stdcall; external 'WBOTHO.DLL' name 'SignLogIn';
function SignLogOut:WORD;
 stdcall; external 'WBOTHO.DLL' name 'SignLogOut';
{************Подпись и проверка подписи***********}
{src_file_name - Имя подписываемого файла}
{dst_file_name - имя подписанного файла}
{name - идентификатор абонента}
function SignFile(src_file_name,dst_file_name,name:LPSTR):WORD;
 stdcall; external 'WBOTHO.DLL' name 'SignFile';
{file_name - полное имя файла}
{count - число обнаруженных подписей}
{stat_array- массив результатов проверки каждой подписи}
function check_file_sign(file_name:LPSTR;count:PByte;stat_array:pCheck_Status):WORD;
 stdcall; external 'WBOTHO.DLL' name 'check_file_sign';
procedure FreeMemory (lpMemory:Pointer);
 stdcall; external 'WBOTHO.DLL' name 'FreeMemory';
{file_name - полное имя файла}
{count - кол-во удаляемых подписей (-1)удалить все подписи}
function DelSign(file_name:LPSTR;count:Byte):WORD;
 stdcall; external 'WBOTHO.DLL' name 'DelSign';
{**************Получить открытый ключ из справочника************}
{base_dir - базовый путь к справочнику открытых ключей}
{open_key_ID - идентификатор открытого ключа}
{key - указатель на буфер для открытого ключа 304 байта}
function ExtractKey(base_dir,open_key_ID:LPSTR;key:Pointer):WORD;
 stdcall; external 'WBOTHO.DLL' name 'ExtractKey';
{******** Функции  работы с ключами ************}
{key_dev - строка с именем ключевого устройства или дескриптор контекста ридера}
{key_ID  - идентификатор ключа или пустая строка ("")}
{function InitKey (key_dev:String; key_ID:String):Word;}
function InitKey (key_dev:Pointer; key_ID:LPSTR):WORD;
 stdcall; external 'WBOTHO.DLL' name 'InitKey';
{key_ID - идентификатор ключа}
{flag   - признак возможности выгрузки ключа из "слота"0}
function ResetKeyEx(key_ID:LPSTR;flag:Integer):Word;
  stdcall; external 'WBOTHO.DLL' name 'ResetKeyEx';

Procedure TVerba.VerbaInit;{}
Begin
 {Key[1]:='2110941035';}
 Key[1]:='5110941035';
 {Key[2]:='6419941009';}
 Key[2]:='2291942009';
 Key[3]:='2110941035';
 Key[4]:='2110941035';
 Key[5]:='2110941035';
 Key[6]:='2110941035';
 Key[7]:='2110941035';
 Key[8]:='2110941035';
 OpenKey[1]:='941035';
 OpenKey[2]:='941009';
 OpenKey[3]:='941035';
 OpenKey[4]:='941009';
 PathKey[1]:='F:\';
 {PathKey[2]:='A:\';}
 PathKey[2]:='G:\';
 PathKey[3]:='H:\';
 PathKey[4]:='I:\';
 PathOpenKey[1]:='c:\\Verba\\1\\';
 PathOpenKey[2]:='c:\\Verba\\2\\';
 PathOpenKey[3]:='c:\\Verba\\3\\';
 PathOpenKey[4]:='c:\\Verba\\4\\';
End;

Procedure TVerba.RepathFile;{проставить // в пути к фаилу}

Begin
 PathFileIn:= StringReplace(PathFileIn,'\', '\\', [rfReplaceAll, rfIgnoreCase]);
 PathFileOut:= StringReplace(PathFileOut,'\', '\\', [rfReplaceAll, rfIgnoreCase]);
End;

Function TVerba.Uncript(KeyId:Integer):Word;{Разкриптовать 3 ключем}
var
 err_code:Word;
 sender_key:array [0..304] of byte;
begin
 RepathFile;
 Result:=0;
 err_code:=InitRndm(PathKey[KeyId], 1);
 Result:=err_code;
 if err_code = 0 then begin
  err_code:=CryptoInit(PathKey[KeyId],PathOpenKey[KeyId]);
  Result:=err_code;
  if err_code = 0 then begin
   err_code:=GetFileSenderID(PChar(PathFileIn), PChar(Key[KeyId+4]));
   Result:=err_code;
   if err_code = 0 then begin
    err_code:=ExtractKey(PChar(Verba.PathOpenKey[KeyId]),PChar(Key[KeyId+4]), @sender_key);
    Result:=err_code;
    if err_code = 0 then begin
     err_code:=DeCryptFileEx (PChar(PathFileIn), PChar(PathFileOut),PChar(Key[KeyId]) , @sender_key);
     Result:=err_code;
    end;
   end;
  end;
  CryptoDone;
 end;

End;

Function TVerba.UncriptFolder(KeyId:Integer):Word;{Разкриптовать 3 ключем}
var
 err_code:Word;
 sender_key:array [0..304] of byte;
 FindRes:Integer;
 SerchFile:TSearchRec;
begin
 Result:=0;
 err_code:=InitRndm(PathKey[KeyId], 1);
 Result:=err_code;
 if err_code = 0 then begin
  err_code:=CryptoInit(PathKey[KeyId],PathOpenKey[KeyId]);
  Result:=err_code;
  if err_code = 0 then begin
   FindRes:=Findfirst(Folder+'*.*',faAnyFile,SerchFile);
   {Читаем все в каталогие}
   While FindRes=0 do
   Begin
    If (SerchFile.Name<>'.') and (SerchFile.Name<>'..') then
    Begin
     PathFileIn:=Verba.Folder+SerchFile.Name;
     PathFileOut:=Verba.FolderOut+SerchFile.Name;
     err_code:=GetFileSenderID(PChar(PathFileIn), PChar(Key[KeyId+4]));
     Result:=err_code;
     if err_code = 0 then
     begin
      err_code:=ExtractKey(PChar(Verba.PathOpenKey[KeyId]),PChar(Key[KeyId+4]), @sender_key);
      Result:=err_code;
      if err_code = 0 then
      begin
       err_code:=DeCryptFileEx (PChar(PathFileIn), PChar(PathFileOut),PChar(Key[KeyId]) , @sender_key);
       Result:=err_code;
       If Result=0 then
       Begin
        DeleteFile(PathFileIn);
        Form1.ListBox3.Items.Add('Разкриптован пакет - '+SerchFile.Name);
        LoadLog('Adm','Разкриптован пакет - '+SerchFile.Name);
       End;
       If Result>0 then
       Begin
        Form1.ListBox3.Items.Add('Ошибка вербы - '+SerchFile.Name);
        LoadLog('Adm','Ошибка вербы - '+SerchFile.Name);
        Break;
       End;
      End;
     End;
     If err_code=29 then MoveFile(PChar(PathFileIn),PChar(PathFileOut));
    end;
    FindRes:=FindNext(SerchFile);
   end;
   FindClose(SerchFile);
  end;
  CryptoDone;
 end;
End;

Function TVerba.Sign(KeyId:Integer):Word;{Разкриптовать 3 ключем}
var
 err_code: Word;
begin
 err_code:=InitKey(PChar(PathKey[KeyId]),'');
 Result:=err_code;
 if err_code = 0 then
 begin
  err_code := SignInit(PChar(PathKey[KeyId]), PChar(PathOpenKey[KeyId]));
  Result:=err_code;
  if err_code = 0 then
  begin
   err_code := SignFile(PChar(PathFileIn), PChar(PathFileOut), PChar(Key[KeyId]+'02'));
   Result:=err_code;
   SignDone;
   ResetKeyEx(PChar(Key[KeyId]+'02'), 1);
  End;
 End;
end;

Function TVerba.SignFolder(KeyId:Integer):Word;{Разкриптовать 3 ключем}
var
 ColFiles:Integer;
 err_code: Word;
 FindRes:Integer;
 SerchFile:TSearchRec;
begin
 ColFiles:=0;
 err_code:=InitKey(PChar(PathKey[KeyId]),'');
 Result:=err_code;
 If err_code>0 then
 Begin
  Form1.ListBox3.Items.Add('Ошибка Вербы - '+IntToStr(err_code));
  LoadLog('Adm','Ошибка Вербы - '+IntToStr(err_code));
 End;
 if err_code = 0 then
 begin
  err_code := SignInit(PChar(PathKey[KeyId]), PChar(PathOpenKey[KeyId]));
  Result:=err_code;
  If err_code>0 then
  Begin
   Form1.ListBox3.Items.Add('Ошибка Вербы - '+IntToStr(err_code));
   LoadLog('Adm','Ошибка Вербы - '+IntToStr(err_code));
  End;
  if err_code = 0 then
  begin
   FindRes:=Findfirst(Folder+'*.*',faAnyFile,SerchFile);
   {Читаем все в каталогие}
   While FindRes=0 do
   Begin
    If (SerchFile.Name<>'.') and (SerchFile.Name<>'..') then
    Begin
     PathFileIn:=Verba.Folder+SerchFile.Name;
     PathFileOut:=Verba.FolderOut+SerchFile.Name;
     If KeyId=1 then err_code := SignFile(PChar(PathFileIn), PChar(PathFileOut), PChar(Key[KeyId]+'02'));
     If KeyId=3 then err_code := SignFile(PChar(PathFileIn), PChar(PathFileOut), PChar(Key[KeyId]+'01'));
     If err_code>0 then
     Begin
      Form1.ListBox3.Items.Add('Ошибка Вербы - '+IntToStr(err_code));
      LoadLog('Adm','Ошибка Вербы - '+IntToStr(err_code));
     End;
     Result:=err_code;
     If Result=0 then
     Begin
      DeleteFile(PathFileIn);
      ColFiles:=ColFiles+1;
     End;
     If Result>0 then Break;
    End;
    FindRes:=FindNext(SerchFile);
   End;
   FindClose(SerchFile);
  End;
  SignDone;
 End;
 If KeyId=1 then ResetKeyEx(PChar(Key[KeyId]+'02'), 1);
 If KeyId=3 then ResetKeyEx(PChar(Key[KeyId]+'01'), 1);
 If ColFiles>0 then
 Begin
  Form1.ListBox3.Items.Add('Подписано - '+IntToStr(ColFiles)+' файлов');
  LoadLog('Adm','Подписано - '+IntToStr(ColFiles)+' файлов');
 End;
end;

Function TVerba.Cript(KeyId:Integer):Word;{Разкриптовать}
var
 err_code, from: Word;
 CAbonent: array [0..1] of word;
begin
 err_code:=InitKey(PChar(PathKey[KeyId]),PChar(Key[KeyId]));
 Result:=err_code;
 if err_code = 0 then
 begin
  err_code:=CryptoInit(PathKey[KeyId],PathOpenKey[KeyId]);
  Result:=err_code;
  if err_code = 0 then
  begin
   CAbonent[0]:=StrToInt('0020'); CAbonent[1]:=0; from:=StrToInt(copy(Key[KeyId], 1, 4));
   Result := EnCryptFile(PChar(PathFileIn), PChar(PathFileOut), from, @CAbonent, PChar(copy(Key[KeyId], 5, 6)));
  end;
  CryptoDone;
  ResetKeyEx(PChar(Key[KeyId]), 1);
 End;
End;

Function TVerba.CriptFolder(KeyId:Integer):Word;{Разкриптовать}
var
 err_code, from: Word;
 ColFiles:Integer;
 CAbonent: array [0..1] of word;
 FindRes:Integer;
 SerchFile:TSearchRec;
begin
 err_code:=InitKey(PChar(PathKey[KeyId]),PChar(Key[KeyId]));
 Result:=err_code;
 if err_code = 0 then
 begin
  err_code:=CryptoInit(PathKey[KeyId],PathOpenKey[KeyId]);
  Result:=err_code;
  if err_code = 0 then
  begin
   CAbonent[0]:=StrToInt('9020'); CAbonent[1]:=0; from:=StrToInt(copy(Key[KeyId], 1, 4));
   FindRes:=Findfirst(Folder+'*.*',faAnyFile,SerchFile);
   {Читаем все в каталогие}
   ColFiles:=0;
   While FindRes=0 do
   Begin
    If (SerchFile.Name<>'.') and (SerchFile.Name<>'..') then
    Begin
     PathFileIn:=Verba.Folder+SerchFile.Name;
     PathFileOut:=Verba.FolderOut+SerchFile.Name;
     err_code:=EnCryptFile(PChar(PathFileIn), PChar(PathFileOut), from, @CAbonent, PChar(copy(Key[KeyId], 5, 6)));
     If err_code>0 then
     Begin
      Form1.ListBox3.Items.Add('Ошибка Вербы - '+IntToStr(err_code));
      LoadLog('Adm','Ошибка Вербы - '+IntToStr(err_code));
     End;
     Result:=err_code;
     If Result=0 then
     Begin
      DeleteFile(PathFileIn);
      ColFiles:=ColFiles+1;
     End;
     If Result>0 then Break;
    End;
    FindRes:=FindNext(SerchFile);
   End;
   FindClose(SerchFile);
  end;
  CryptoDone;
 End;
 ResetKeyEx(PChar(Key[KeyId]), 1);
 If ColFiles>0 then
 Begin
  Form1.ListBox3.Items.Add('Закриптовано - '+IntToStr(ColFiles)+' файлов');
  LoadLog('Adm','Закриптовано - '+IntToStr(ColFiles)+' файлов');
 End;
End;

Function TVerba.UnCaFolder(KeyId:Integer):Word;{Разкриптовать}
var
 err_code, from: Word;
 ColFiles:Integer;
 CAbonent: array [0..1] of word;
 FindRes:Integer;
 SerchFile:TSearchRec;
begin

 err_code:=InitRndm(PathKey[KeyId], 1);
 if err_code = 0 then
 begin
  err_code := SignInit(PChar(PathKey[KeyId]), PChar(PathOpenKey[KeyId]));
  Result:=err_code;
  if err_code = 0 then
  begin
   FindRes:=Findfirst(Folder+'*.*',faAnyFile,SerchFile);
   {Читаем все в каталогие}
   ColFiles:=0;
   While FindRes=0 do
   Begin
    If (SerchFile.Name<>'.') and (SerchFile.Name<>'..') then
    Begin
     err_code:=DelSign(PChar(Folder+SerchFile.Name), 255);
     Result:=err_code;
     If err_code>0 then
     Begin
      Result:=err_code;
     End
     Else
     Begin
      ColFiles:=ColFiles+1;
     End;
    End;
    FindRes:=FindNext(SerchFile);
   End;
   FindClose(SerchFile);
  End;
 End;
 Form1.ListBox3.Items.Add('Снята КА с - '+IntToStr(ColFiles)+' файлов');
 LoadLog('Adm','Снята КА с - '+IntToStr(ColFiles)+' файлов');
 SignDone;
End;




{1. Инициализация датчика случайных чисел:}
{Способ 1. Невидимый для пользователя, через файл asrkeyw.exe:}

procedure InitAsrKey;
var
 HWind, H1: HWND;
 Wind: String;
begin
 Wind:='asrkeyw';
 if ShellExecute(0,'open', PChar(Wind+'.exe'), nil, nil, SW_SHOWMINNOACTIVE) > 31 then begin
  HWind:=0;
  Repeat
   HWind:=FindWindow(nil, PChar(Wind));
  Until HWind<>0; //Ждемс
  While not IsWindowVisible(HWind) do Application.ProcessMessages;
  // Если не инициализирован датчик случайных чисел, то делаем инициализацию
  Repeat
   H1:=FindWindowEx(HWind, 0, 'Static', 'НАЖИМАЙТЕ ЛЮБЫЕ КЛАВИШИ ИЛИ ПОДВИГАЙТЕ  МЫШЬЮ ...');
  Until H1<>0;
  while IsWindowVisible(H1) do begin
   SendMessage(HWind,WM_LButtonDown,1,1);
   SendMessage(HWind,WM_LButtonUp  ,1,1);
   Application.ProcessMessages;
  end;
  SendMessage (HWind, WM_CLOSE, 0, 0);
 end;
end;

{6. Убираем подпись с файла, попутно пытаясь его разархивировать, используя библиотеку mpacker.dll:}
function DeCompressFile (infile, outfile: LPSTR):WORD; cdecl external 'mpacker.dll' name 'DeCompressFile';
procedure pDeSignFile (mFile: String);
var
 err_code: Word;
begin
 // Попытка разархивировать файл
 DeCompressFile (PChar(mFile), PChar(mFile));
 // Инициализация датчика случайных чисел
 err_code:=InitRndm(PChar('A:\'), 1);
 // Инициализация криптоключа
 if err_code = 0 then begin
 // Инициализация ключа подписи
  err_code:=SignInit(PChar('A:'), PChar('Путь_до_справочников'));
  if err_code = 0 then
   // Удаление подписи
   err_code:=DelSign(PChar(mFile), 255);
   // Завершение работы
   SignDone;
  end;
 End;

{7. Дополнительно. Что бы не использовать дисковод и диск А:, вы можете смапировать любую папку жесткого диска или флешки на диск B:. Подпись будет осуществляться в разы быстрее:}
{function MapDisk(PathMap: String): Boolean;
var
 CurrentMap: String;
 function DiskPresent(Letter : Char) : Boolean;
 Begin
  Result:= ((GetLogicalDrives AND (Ord(Letter)-64)) > 0);
 End;
 function Subst: Boolean;
 begin
  Result:=True;
  if (not DefineDosDevice(0, PChar(DiskForSign + ':'), PChar(PathMap))) then begin
   AddLog('Не удалось подключить криптографический диск [' + PathMap + '].');
   Result:=False;
  end else
  AddLog('На устройство ' + DiskForSign + ' смапировано ' + PathMap);
 end;
 function SubstQuery: string;
 var
  buff: array[0..256] of char;
  begin
   buff[0] := #0;
   QueryDosDevice(PChar(DiskForSign + ':'), buff, 256);
   Result := StrPas(buff);
   if Copy(Result,1,4) = '\??\' then Result := Copy(Result, 5, Length(Result)) else Result:='';
  end;
begin
 Result:=False;
 if DiskPresent(DiskForSign[1]) then
 begin
  CurrentMap := SubstQuery;
  if PathMap = CurrentMap then Result:=True
  else if (DefineDosDevice(DDD_REMOVE_DEFINITION, PChar(DiskForSign + ':'), PChar(CurrentMap))) then Result:=Subst
 end
 else Result:=Subst;
end;}


end.
